------------eclosure--------------------

#include<stdio.h>
#include<stdlib.h>
struct node
{
    int st;
    struct node *link;
};
void findclosure(int,int);
void insert_trantbl(int ,char, int);
int findalpha(char);
void print_e_closure(int);
static int set[20],nostate,noalpha,s,notransition,c,r,buffer[20];
char alphabet[20];
static int e_closure[20][20]={0};
struct node * transition[20][20]={NULL};

void main()
{
    int i,j,k,m,t,n;
    struct node *temp;                                                                                                                                                                                                                              
    printf("Enter the number of alphabets\n");
    scanf("%d",&noalpha);
    getchar();
    printf("NOTE:- [ use letter e as epsilon]\n");
    printf("NOTE:- [e must be last character ,if it is present]\n");
    printf("\nEnter alphabets?\n");
    for(i=0;i<noalpha;i++)
    {
        alphabet[i]=getchar();
        getchar();
    }
    printf("\nEnter the number of states?\n");
    scanf("%d",&nostate);
    printf("\nEnter no of transition?\n");
    scanf("%d",&notransition);
    printf("NOTE:- [Transition is in the form–> qno alphabet qno]\n",notransition);
    printf("NOTE:- [States number must be greater than zero]\n");
    printf("\nEnter transition?\n");
    for(i=0;i<notransition;i++)
    { 
        scanf("%d %c%d",&r,&c,&s);
        insert_trantbl(r,c,s);
    }
    printf("\n");
    printf("e-closure of states……\n");
    printf("—————————–\n");
    for(i=1;i<=nostate;i++)
    {
        c=0;
        for(j=0;j<20;j++)
        {
            buffer[j]=0;
            e_closure[i][j]=0;
        }
        findclosure(i,i);
        printf("\ne-closure(q%d): ",i);
        print_e_closure(i);
        }
}

void findclosure(int x,int sta)
{
    struct node *temp;
    int i;
    if(buffer[x])
        return;
    e_closure[sta][c++]=x;
    buffer[x]=1;
    if(alphabet[noalpha-1]=='e' && transition[x][noalpha-1]!=NULL)
    {
        temp=transition[x][noalpha-1];
        while(temp!=NULL)
        {
            findclosure(temp->st,sta);
            temp=temp->link;
        }
    }
}

void insert_trantbl(int r,char c,int s)
{
    int j;
    struct node *temp;
    j=findalpha(c);
    if(j==999)
    {
        printf("error\n");
        exit(0);
    }
    temp=(struct node *)malloc(sizeof(struct node));
    temp->st=s;
    temp->link=transition[r][j];
    transition[r][j]=temp;
}

int findalpha(char c)
{
    int i;
    for(i=0;i<noalpha;i++)
        if(alphabet[i]==c)
            return i;
    return(999);
}

void print_e_closure(int i)
{
    int j;
    printf("{");
    for(j=0;e_closure[i][j]!=0;j++)
        printf("q%d,",e_closure[i][j]);
    printf("}");
}












--------------------------------enfa-nfa--------------------------------------------

#include<stdio.h>
#include<stdlib.h>
struct node
{
        int st;
        struct node *link;
};

void findclosure(int,int);
void insert_trantbl(int ,char, int);
int findalpha(char);
void findfinalstate(void);
void unionclosure(int);
void print_e_closure(int);
static int set[20],nostate,noalpha,s,notransition,nofinal,start,finalstate[20],c,r,buffer[20];
char alphabet[20];
static int e_closure[20][20]={0};
struct node * transition[20][20]={NULL};
void main()
{
           int i,j,k,m,t,n;

           struct node *temp;
           printf("enter the number of alphabets?\n");
           scanf("%d",&noalpha);
           getchar();
           printf("NOTE:- [ use letter e as epsilon]\n");

          printf("NOTE:- [e must be last character ,if it is present]\n");

          printf("\nEnter alphabets?\n");
          for(i=0;i<noalpha;i++)
         {

                  alphabet[i]=getchar();
                  getchar();
        }
        printf("Enter the number of states?\n");
        scanf("%d",&nostate);
        printf("Enter the start state?\n");
        scanf("%d",&start);
        printf("Enter the number of final states?\n");
        scanf("%d",&nofinal);
        printf("Enter the final states?\n");
        for(i=0;i<nofinal;i++)
                scanf("%d",&finalstate[i]);
         printf("Enter no of transition?\n");
        scanf("%d",&notransition);
        printf("NOTE:- [Transition is in the form--> qno   alphabet   qno]\n",notransition);
        printf("NOTE:- [States number must be greater than zero]\n");
        printf("\nEnter transition?\n");
        for(i=0;i<notransition;i++)
        {

 
                scanf("%d %c%d",&r,&c,&s);
                insert_trantbl(r,c,s);

        }

        printf("\n");

        for(i=1;i<=nostate;i++)
        {
                c=0;
                for(j=0;j<20;j++)

                {
                              buffer[j]=0;
                               e_closure[i][j]=0;
                }
                findclosure(i,i);
        }
        printf("Equivalent NFA without epsilon\n");
        printf("-----------------------------------\n");
        printf("start state:");
        print_e_closure(start);
        printf("\nAlphabets:");
        for(i=0;i<noalpha;i++)
                  printf("%c ",alphabet[i]);
        printf("\nStates :" );
        for(i=1;i<=nostate;i++)
                  print_e_closure(i);

        printf("\nTransitions are...:\n");

        for(i=1;i<=nostate;i++)
        {

                  for(j=0;j<noalpha-1;j++)
                 {
                          for(m=1;m<=nostate;m++)
                                        set[m]=0;
                          for(k=0;e_closure[i][k]!=0;k++)
                          {

                                    t=e_closure[i][k];
                                   temp=transition[t][j];
                                   while(temp!=NULL)
                                  {

                                             unionclosure(temp->st);
                                            temp=temp->link;
                                   }
                         }
                        printf("\n");
                        print_e_closure(i);
                        printf("%c\t",alphabet[j]    );
                        printf("{");
                        for(n=1;n<=nostate;n++)
                        {
                                     if(set[n]!=0)
                                             printf("q%d,",n);
                        }
                         printf("}");
                }
        }
        printf("\nFinal states:");
        findfinalstate();




}

void findclosure(int x,int sta)
{
            struct node *temp;
            int i;
           if(buffer[x])
                     return;
             e_closure[sta][c++]=x;
            buffer[x]=1;
             if(alphabet[noalpha-1]=='e' && transition[x][noalpha-1]!=NULL)
                {
                             temp=transition[x][noalpha-1];
                             while(temp!=NULL)
                            {
                                         findclosure(temp->st,sta);
                                         temp=temp->link;
                             }
                }
  }

void insert_trantbl(int r,char c,int s)
{
           int j;
           struct node *temp;
            j=findalpha(c);
          if(j==999)
          {
                     printf("error\n");
                    exit(0);
          }
         temp=(struct node *) malloc(sizeof(struct node));
         temp->st=s;
         temp->link=transition[r][j];
         transition[r][j]=temp;
}

int findalpha(char c)
{
            int i;
            for(i=0;i<noalpha;i++)
                   if(alphabet[i]==c)
                          return i;

                return(999);


}

void unionclosure(int i)
{
              int j=0,k;
             while(e_closure[i][j]!=0)
             {
                      k=e_closure[i][j];
                      set[k]=1;
                      j++;
             }
}
void findfinalstate()
{
            int i,j,k,t;
            for(i=0;i<nofinal;i++)
           {
                      for(j=1;j<=nostate;j++)
                      {
                              for(k=0;e_closure[j][k]!=0;k++)
                                {
                                         if(e_closure[j][k]==finalstate[i])
                                        {

                                                 print_e_closure(j);
                                        }
                               }
                      }
             }


  }

void print_e_closure(int i)
{
        int j=0;
        printf("{");
       if(e_closure[i][j]!=0)
                        printf("q%d,",e_closure[i][0]);
         printf("}\t");
}




-----------------nfa-dfa-------------------------------------------

#include<stdio.h>
#include<stdlib.h>
struct node
{
 int st;
 struct node *link;
};
struct node1
{

 int nst[20];
};

void insert(int ,char, int);
int findalpha(char);
void findfinalstate(void);
int insertdfastate(struct node1);
int compare(struct node1,struct node1);
void printnewstate(struct node1);
static int set[20],nostate,noalpha,s,notransition,nofinal,start,finalstate[20],c,r,buffer[20];
int complete=-1;
char alphabet[20];
static int eclosure[20][20]={0};
struct node1 hash[20];
struct node * transition[20][20]={NULL};
void main()
{
 int i,j,k,m,t,n,l;
 struct node *temp;
 struct node1 newstate={0},tmpstate={0};
 
 printf("Enter the number of alphabets?\n");
 printf("NOTE:- [ use letter e as epsilon]\n");
 printf("NOTE:- [e must be last character ,if it is present]\n");
 printf("\nEnter No of alphabets and alphabets?\n");
 scanf("%d",&noalpha);
 getchar();
 for(i=0;i<noalpha;i++)
 {

 alphabet[i]=getchar();
 getchar();
 }
 printf("Enter the number of states?\n");
 scanf("%d",&nostate);
 printf("Enter the start state?\n");
 scanf("%d",&start);
 printf("Enter the number of final states?\n");
 scanf("%d",&nofinal);
 printf("Enter the final states?\n");
 for(i=0;i<nofinal;i++)
 scanf("%d",&finalstate[i]);
 printf("Enter no of transition?\n");

 scanf("%d",&notransition);
 printf("NOTE:- [Transition is in the form–> qno alphabet qno]\n",notransition);
 printf("NOTE:- [States number must be greater than zero]\n");
 printf("\nEnter transition?\n");


 for(i=0;i<notransition;i++)
 {


  scanf("%d %c%d",&r,&c,&s);
  insert(r,c,s);

 }
 for(i=0;i<20;i++)
 {
  for(j=0;j<20;j++)
  hash[i].nst[j]=0;
 }
 complete=-1;
 i=-1;
 printf("\nEquivalent DFA.....\n");
 printf("Trnsitions of DFA\n");

 newstate.nst[start]=start;
 insertdfastate(newstate);
 while(i!=complete)
 {
  i++;
  newstate=hash[i];
  for(k=0;k<noalpha;k++)
  {
   c=0;
   for(j=1;j<=nostate;j++)
   set[j]=0;
   for(j=1;j<=nostate;j++)
   {
    l=newstate.nst[j];
    if(l!=0)
    {
     temp=transition[l][k];
     while(temp!=NULL)
     {
      if(set[temp->st]==0)
      {
       c++;
       set[temp->st]=temp->st;
      }
      temp=temp->link;


     }
    }
   }
   printf("\n");
   if(c!=0)
   {
    for(m=1;m<=nostate;m++)
     tmpstate.nst[m]=set[m];

    insertdfastate(tmpstate);

    printnewstate(newstate);
    printf("%c\t",alphabet[k]);
    printnewstate(tmpstate);
    printf("\n");
   }
   else
   {
    printnewstate(newstate);
    printf("%c\t", alphabet[k]);
    printf("NULL\n");
   }

  }
   }
 printf("\nStates of DFA:\n");
 for(i=0;i<=complete;i++)
 printnewstate(hash[i]);  
 printf("\n Alphabets:\n");
 for(i=0;i<noalpha;i++)
 printf("%c\t",alphabet[i]);
 printf("\n Start State:\n");
 printf("q%d",start);
 printf("\nFinal states:\n");
 findfinalstate();

}
int insertdfastate(struct node1 newstate)
{
 int i;
 for(i=0;i<=complete;i++)
 {
  if(compare(hash[i],newstate))
   return 0;
 }
 complete++;
 hash[complete]=newstate;
 return 1;
}
int compare(struct node1 a,struct node1 b)
{
 int i;


  for(i=1;i<=nostate;i++)
  {
   if(a.nst[i]!=b.nst[i])
    return 0;
  }
  return 1;


}

void insert(int r,char c,int s)
{
       int j;
       struct node *temp;
       j=findalpha(c);
       if(j==999)
       {
  printf("error\n");
  exit(0);
       }
       temp=(struct node *) malloc(sizeof(struct node));
       temp->st=s;
       temp->link=transition[r][j];
       transition[r][j]=temp;
}

int findalpha(char c)
{
 int i;
 for(i=0;i<noalpha;i++)
 if(alphabet[i]==c)
  return i;

  return(999);


}


void findfinalstate()
{
 int i,j,k,t;

 for(i=0;i<=complete;i++)
 {
  for(j=1;j<=nostate;j++)
  {
   for(k=0;k<nofinal;k++)
   {
    if(hash[i].nst[j]==finalstate[k])
    {
     printnewstate(hash[i]);
     printf("\t");
     j=nostate;
     break;
    }
   }
  }
 }
}


void printnewstate(struct node1 state)
{
 int j;
 printf("{");
  for(j=1;j<=nostate;j++)
  {
   if(state.nst[j]!=0)
    printf("q%d,",state.nst[j]);
  }
  printf("}\t");

}


--------------------------dfaamin-------------------------------------


#include <stdio.h>
#include <string.h>
 
#define STATES  99
#define SYMBOLS 20
 
int N_symbols;  /* number of input symbols */
int N_DFA_states;   /* number of DFA states */
char *DFA_finals;   /* final-state string */
int DFAtab[STATES][SYMBOLS];
 
char StateName[STATES][STATES+1];   /* state-name table */
 
int N_optDFA_states;    /* number of optimized DFA states */
int OptDFA[STATES][SYMBOLS];
char NEW_finals[STATES+1];
 
/*
    Print state-transition table.
    State names: 'A', 'B', 'C', ...
*/
void print_dfa_table(
    int tab[][SYMBOLS], /* DFA table */
    int nstates,    /* number of states */
    int nsymbols,   /* number of input symbols */
    char *finals)
{
    int i, j;
 
    puts("\nDFA: STATE TRANSITION TABLE");
 
    /* input symbols: '0', '1', ... */
    printf("     | ");
    for (i = 0; i < nsymbols; i++) printf("  %c  ", '0'+i);
 
    printf("\n-----+--");
    for (i = 0; i < nsymbols; i++) printf("-----");
    printf("\n");
 
    for (i = 0; i < nstates; i++) {
        printf("  %c  | ", 'A'+i);  /* state */
        for (j = 0; j < nsymbols; j++)
            printf("  %c  ", tab[i][j]);    /* next state */
        printf("\n");
    }
    printf("Final states = %s\n", finals);
}
 
/*
    Initialize NFA table.
*/
void load_DFA_table()
{
 
    DFAtab[0][0] = 'B'; DFAtab[0][1] = 'C';
    DFAtab[1][0] = 'E'; DFAtab[1][1] = 'F';
    DFAtab[2][0] = 'A'; DFAtab[2][1] = 'A';
    DFAtab[3][0] = 'F'; DFAtab[3][1] = 'E';
    DFAtab[4][0] = 'D'; DFAtab[4][1] = 'F';
    DFAtab[5][0] = 'D'; DFAtab[5][1] = 'E';
 
    DFA_finals = "EF";
    N_DFA_states = 6;
    N_symbols = 2;
}
 
/*
    Get next-state string for current-state string.
*/
void get_next_state(char *nextstates, char *cur_states,
    int dfa[STATES][SYMBOLS], int symbol)
{
    int i, ch;
 
    for (i = 0; i < strlen(cur_states); i++)
        *nextstates++ = dfa[cur_states[i]-'A'][symbol];
    *nextstates = '\0';
}
 
/*
    Get index of the equivalence states for state 'ch'.
    Equiv. class id's are '0', '1', '2', ...
*/
char equiv_class_ndx(char ch, char stnt[][STATES+1], int n)
{
    int i;
 
    for (i = 0; i < n; i++)
        if (strchr(stnt[i], ch)) return i+'0';
    return -1;  /* next state is NOT defined */
}
 
/*
    Check if all the next states belongs to same equivalence class.
    Return value:
        If next state is NOT unique, return 0.
        If next state is unique, return next state --> 'A/B/C/...'
    's' is a '0/1' string: state-id's
*/
char is_one_nextstate(char *s)
{
    char equiv_class;   /* first equiv. class */
 
    while (*s == '@') s++;
    equiv_class = *s++; /* index of equiv. class */
 
    while (*s) {
        if (*s != '@' && *s != equiv_class) return 0;
        s++;
    }
 
    return equiv_class; /* next state: char type */
}
 
int state_index(char *state, char stnt[][STATES+1], int n, int *pn,
    int cur)    /* 'cur' is added only for 'printf()' */
{
    int i;
    char state_flags[STATES+1]; /* next state info. */
 
    if (!*state) return -1; /* no next state */
 
    for (i = 0; i < strlen(state); i++)
        state_flags[i] = equiv_class_ndx(state[i], stnt, n);
    state_flags[i] = '\0';
 
    printf("   %d:[%s]\t--> [%s] (%s)\n",
        cur, stnt[cur], state, state_flags);
 
    if (i=is_one_nextstate(state_flags))
        return i-'0';   /* deterministic next states */
    else {
        strcpy(stnt[*pn], state_flags); /* state-division info */
        return (*pn)++;
    }
}
 
/*
    Divide DFA states into finals and non-finals.
*/
int init_equiv_class(char statename[][STATES+1], int n, char *finals)
{
    int i, j;
 
    if (strlen(finals) == n) {  /* all states are final states */
        strcpy(statename[0], finals);
        return 1;
    }
 
    strcpy(statename[1], finals);   /* final state group */
 
    for (i=j=0; i < n; i++) {
        if (i == *finals-'A') {
            finals++;
        } else statename[0][j++] = i+'A';
    }
    statename[0][j] = '\0';
 
    return 2;
}
 
/*
    Get optimized DFA 'newdfa' for equiv. class 'stnt'.
*/
int get_optimized_DFA(char stnt[][STATES+1], int n,
    int dfa[][SYMBOLS], int n_sym, int newdfa[][SYMBOLS])
{
    int n2=n;       /* 'n' + <num. of state-division info> */
    int i, j;
    char nextstate[STATES+1];
 
    for (i = 0; i < n; i++) {    /* for each pseudo-DFA state */
        for (j = 0; j < n_sym; j++) {    /* for each input symbol */
            get_next_state(nextstate, stnt[i], dfa, j);
            newdfa[i][j] = state_index(nextstate, stnt, n, &n2, i)+'A';
        }
    }
 
    return n2;
}
 
/*
    char 'ch' is appended at the end of 's'.
*/
void chr_append(char *s, char ch)
{
    int n=strlen(s);
 
    *(s+n) = ch;
    *(s+n+1) = '\0';
}
 
void sort(char stnt[][STATES+1], int n)
{
    int i, j;
    char temp[STATES+1];
 
    for (i = 0; i < n-1; i++)
        for (j = i+1; j < n; j++)
            if (stnt[i][0] > stnt[j][0]) {
                strcpy(temp, stnt[i]);
                strcpy(stnt[i], stnt[j]);
                strcpy(stnt[j], temp);
            }
}
 
/*
    Divide first equivalent class into subclasses.
        stnt[i1] : equiv. class to be segmented
        stnt[i2] : equiv. vector for next state of stnt[i1]
    Algorithm:
        - stnt[i1] is splitted into 2 or more classes 's1/s2/...'
        - old equiv. classes are NOT changed, except stnt[i1]
        - stnt[i1]=s1, stnt[n]=s2, stnt[n+1]=s3, ...
    Return value: number of NEW equiv. classses in 'stnt'.
*/
int split_equiv_class(char stnt[][STATES+1],
    int i1, /* index of 'i1'-th equiv. class */
    int i2, /* index of equiv. vector for 'i1'-th class */
    int n,  /* number of entries in 'stnt' */
    int n_dfa)  /* number of source DFA entries */
{
    char *old=stnt[i1], *vec=stnt[i2];
    int i, n2, flag=0;
    char newstates[STATES][STATES+1];   /* max. 'n' subclasses */
 
    for (i=0; i < STATES; i++) newstates[i][0] = '\0';
 
    for (i=0; vec[i]; i++)
        chr_append(newstates[vec[i]-'0'], old[i]);
 
    for (i=0, n2=n; i < n_dfa; i++) {
        if (newstates[i][0]) {
            if (!flag) {    /* stnt[i1] = s1 */
                strcpy(stnt[i1], newstates[i]);
                flag = 1;   /* overwrite parent class */
            } else  /* newstate is appended in 'stnt' */
                strcpy(stnt[n2++], newstates[i]);
        }
    }
 
    sort(stnt, n2); /* sort equiv. classes */
 
    return n2;  /* number of NEW states(equiv. classes) */
}
 
/*
    Equiv. classes are segmented and get NEW equiv. classes.
*/
int set_new_equiv_class(char stnt[][STATES+1], int n,
    int newdfa[][SYMBOLS], int n_sym, int n_dfa)
{
    int i, j, k;
 
    for (i = 0; i < n; i++) {
        for (j = 0; j < n_sym; j++) {
            k = newdfa[i][j]-'A';   /* index of equiv. vector */
            if (k >= n)  /* equiv. class 'i' should be segmented */
                return split_equiv_class(stnt, i, k, n, n_dfa);
        }
    }
 
    return n;
}
 
void print_equiv_classes(char stnt[][STATES+1], int n)
{
    int i;
 
    printf("\nEQUIV. CLASS CANDIDATE ==>");
    for (i = 0; i < n; i++)
        printf(" %d:[%s]", i, stnt[i]);
    printf("\n");
}
 
/*
    State-minimization of DFA: 'dfa' --> 'newdfa'
    Return value: number of DFA states.
*/
int optimize_DFA(
    int dfa[][SYMBOLS], /* DFA state-transition table */
    int n_dfa,  /* number of DFA states */
    int n_sym,  /* number of input symbols */
    char *finals,   /* final states of DFA */
    char stnt[][STATES+1],  /* state name table */
    int newdfa[][SYMBOLS])  /* reduced DFA table */
{
    char nextstate[STATES+1];
    int n;  /* number of new DFA states */
    int n2; /* 'n' + <num. of state-dividing info> */
 
    n = init_equiv_class(stnt, n_dfa, finals);
 
    while (1) {
        print_equiv_classes(stnt, n);
        n2 = get_optimized_DFA(stnt, n, dfa, n_sym, newdfa);
        if (n != n2)
            n = set_new_equiv_class(stnt, n, newdfa, n_sym, n_dfa);
        else break; /* equiv. class segmentation ended!!! */
    }
 
    return n;   /* number of DFA states */
}
 
/*
    Check if 't' is a subset of 's'.
*/
int is_subset(char *s, char *t)
{
    int i;
 
    for (i = 0; *t; i++)
        if (!strchr(s, *t++)) return 0;
    return 1;
}
 
/*
    New finals states of reduced DFA.
*/
void get_NEW_finals(
    char *newfinals,    /* new DFA finals */
    char *oldfinals,    /* source DFA finals */
    char stnt[][STATES+1],  /* state name table */
    int n)  /* number of states in 'stnt' */
{
    int i;
 
    for (i = 0; i < n; i++)
        if (is_subset(oldfinals, stnt[i])) *newfinals++ = i+'A';
    *newfinals++ = '\0';
}
 
void main()
{
    load_DFA_table();
    print_dfa_table(DFAtab, N_DFA_states, N_symbols, DFA_finals);
 
    N_optDFA_states = optimize_DFA(DFAtab, N_DFA_states,
            N_symbols, DFA_finals, StateName, OptDFA);
    get_NEW_finals(NEW_finals, DFA_finals, StateName, N_optDFA_states);
 
    print_dfa_table(OptDFA, N_optDFA_states, N_symbols, NEW_finals);
}

----------------------------lex analyz------------------------------------

#include <stdio.h>
#include <string.h>
#include <ctype.h>
char line[100];

int is_operator(char c)
{
    switch (c)
    {
        case '+':   
        case '-':   
        case '*':   
        case '/':   
        case '=':   
            printf("%c - Operator\n", c);
            return 1;
    }

    return 0;
}

int is_delimiter(char c)
{
    switch (c)
    {
        case '{':
        case '}':
        case '(':
        case ')':
        case '[':
        case ']':
        case ',':
        case ';':
            printf("%c - Delimiter\n", c);
            return 1;
    }

    return 0;
}

int is_keyword(char buffer[]){
	char keywords[32][10] = {"auto","break","case","char","const","continue","default",
							"do","double","else","enum","extern","float","for","goto",
							"if","int","long","register","return","short","signed",
							"sizeof","static","struct","switch","typedef","union",
							"unsigned","void","volatile","while"};
	int i;
	for(i = 0; i < 32; ++i){
		if(strcmp(keywords[i], buffer) == 0){
			return 1;
		}
	}
return 0;}

void main()
{
    char c;
    FILE *f = fopen("input.txt", "r");

    while (fgets(line, sizeof(line), f))
    {
        // Single line commment '//', skip processing it
        int flag1 = 0;
        for (int i = 0; i < strlen(line); i++)
        {
            if (line[i] == '/' && line[i + 1] == '/')
            {
                flag1 = 1;
                break;
            }       
        }
        if (flag1)
            continue;        

        // Multi-line comment '/**/'
        int flag2 = 0;
        for (int i = 0; i < strlen(line); i++)
        {
            if (line[i] == '/' && line[i + 1] == '*')
            {
                // Skip all lines until '*/' has occured
                while (fgets(line, sizeof(line), f))
                {
                    for (int j = 0; j < strlen(line); j++)
                    {
                        if (line[j] == '*' && line[j + 1] == '/')
                            flag2 = 1;
                    }

                    if (flag2)
                        break;
                }
            }
        }
        if (flag2)
            continue;

        printf("\n%s\n", line);

        char token[100];
        int index = 0;
        strcpy(token, "");

        for (int i = 0; i < strlen(line); i++)
        {
            if (is_operator(line[i]) || is_delimiter(line[i]) || line[i] == ' ' || line[i] == '\t' || line[i] == '\n')
            {
                // Check if the token is an identifier or a keyword
                if (strcmp(token, "") != 0)
                {
                    if (is_keyword(token))
                        printf("%s - Keyword\n", token);
                    else if(isdigit(token[0]))
                        printf("%s - Number\n",token);
                    else
                        printf("%s - Identifier\n", token);

                    strcpy(token, "");
                    index = 0;
                }
            }
            else  
            {
                token[index++] = line[i];
                token[index] = '\0';
            }
        }
    }

    fclose(f);
}

----------------------------------substring-------------------------------------


%{ 
#include<stdio.h> 
#include<string.h> 
int i = 0;
int flag=0; 
char name[50]="";
%} 

%% 
[a-zA-Z]* {
	for(i=0;i<yyleng;i++){
		if(yytext[i]=='n' && yytext[i+1]=='a' && yytext[i+2]=='n' && yytext[i+3]=='d'){
			flag=1;
		}
	}
	strcpy(name,yytext);
}
[\n] {
 if(flag==1){printf("%s contains 4 letters of name as substring\n",name);
 flag=0;
 strcpy(name,"");
 printf("Enter the string    ");
}else{
printf("%s does not contain 4 letters of name as  substring\n",name);
strcpy(name,"");
printf("Enter the string    ");
}
}
%% 


int main() 
{ printf("Enter the string    ");
	// The function that starts the analysis 
	yylex(); 
	return 0; 
} 



---------------------valid--------------------


%{
    #include "y.tab.h"
%}

%%
[a-zA-Z_][a-zA-Z_0-9]* {return letter;}
[0-9] {return digit;}
.  {return yytext[0];}
\n {return 0;}
%%

int yywrap(){
return 1;
}

//////////////////////////////////////////////////////

%{
    #include<stdio.h>
    int valid=1;
    int yyerror();
%}

%token digit letter

%%
start : letter s
s :     letter s
      | digit s
      |
      ;

%%

int yyerror(){  
    printf("\nIts not a identifier!\n");
   valid=0;
   return 0;}

int main(){ 
     printf("\nEnter a name to tested for identifier ");
    yyparse();
    if(valid){
    printf("\nIt is an identifier!\n");
    }
}



---------------------------calculator--------------------------------

%{
#include "y.tab.h"  // Include the header file generated by Yacc
%}

%%

[0-9]+    { yylval = atoi(yytext); return NUMBER; }  
"+"       { return '+'; }  
"-"       { return '-'; }  
"*"       { return '*'; }  
"/"       { return '/'; }  
"("       { return '('; }  
")"       { return ')'; }  
[ \t]+    { /* Ignore spaces and tabs */ }
.         { printf("Unexpected character: %s\n", yytext); }

%%

int yywrap() {
    return 1;
}

/////////////////////////////////////////////////////////

%{
#include <stdio.h>
#include <stdlib.h>

// Declare external functions
void yyerror(char *s);
int yylex(void);


%}

/* Declare tokens */
%token NUMBER

%%
/* Grammar rules for arithmetic expressions */
start:  expression             { printf(" Result is : %d\n", $1); }
        ;

expression:
      expression '+' term         { $$ = $1 + $3; }
    | expression '-' term         { $$ = $1 - $3; }
    | term                        { $$ = $1; }
    ;

term:
      term '*' factor             { $$ = $1 * $3; }
    | term '/' factor             { $$ = $1 / $3; }
    | factor                      { $$ = $1; }
    ;

factor:
      '(' expression ')'          { $$ = $2; }     // Value inside parentheses
    | NUMBER                      { $$ = $1; }     // The value of the number
    ;

%%

/* Main function */
int main() {
    printf("Enter an arithmetic expression: ");
    yyparse();   // Parse the input
    
    return 0;
}

/* Error handling function */
void yyerror(char *s) {
    fprintf(stderr, "Error: %s\n", s);
}


--------------------------bnf-------------------------------------------------



%{
#include"y.tab.h"
#include <stdio.h> 
#include<string.h> 
int LineNo=1;
%}
identifier [a-zA-Z][_a-zA-Z0-9]* 
number [0-9]+|([0-9]*\.[0-9]+)
%%
main\(\) return MAIN;
if return IF;
else return ELSE;
while return WHILE;
int|char|float return TYPE; 
{identifier} {strcpy(yylval.var,yytext); return VAR;} 
{number} {strcpy(yylval.var,yytext);
return NUM;}
\< |
\> |
\>= |
\<= |
== {strcpy(yylval.var,yytext);
return RELOP;}
[ \t] ;
\n LineNo++;
. return yytext[0];
%%
int yywrap() {
    return 1;
}
///////////////////////////////////////////////////////////////

%{
#include<string.h>
 #include<stdio.h> 
struct quad { char op[5];
 char arg1[10]; 
 char arg2[10];
char result[10];
}QUAD[30];
struct stack { int items[100];
 int top; }stk;
int Index=0,tIndex=0,StNo,Ind,tInd; 
extern int LineNo;
%}
%union
{
char var[10];
}
%token <var> NUM VAR RELOP
%token MAIN IF ELSE WHILE TYPE
%type <var> EXPR ASSIGNMENT CONDITION IFST ELSEST WHILELOOP
%left '-' '+'
%left '*' '/'
%%
PROGRAM : MAIN BLOCK
;
BLOCK: '{' CODE '}'
;
CODE: BLOCK
| STATEMENT CODE
| STATEMENT
;
STATEMENT: DESCT ';'
| ASSIGNMENT ';'
| CONDST
| WHILEST
;
DESCT: TYPE VARLIST
;
VARLIST: VAR ',' VARLIST
| VAR
;
ASSIGNMENT: VAR '=' EXPR{ strcpy(QUAD[Index].op,"=");
 strcpy(QUAD[Index].arg1,$3);
  strcpy(QUAD[Index].arg2,""); 
  strcpy(QUAD[Index].result,$1);
   strcpy($$,QUAD[Index++].result);
}
;
EXPR: EXPR '+' EXPR {AddQuadruple("+",$1,$3,$$);}
| EXPR '-' EXPR {AddQuadruple("-",$1,$3,$$);}
| EXPR '*' EXPR {AddQuadruple("*",$1,$3,$$);}
| EXPR '/' EXPR {AddQuadruple("/",$1,$3,$$);}
| '-' EXPR {AddQuadruple("UMIN",$2,"",$$);}
| '(' EXPR ')' {strcpy($$,$2);}
| VAR
| NUM
;
CONDST: IFST{
Ind=pop();
sprintf(QUAD[Ind].result,"%d",Index);
 Ind=pop();
sprintf(QUAD[Ind].result,"%d",Index);
}
| IFST ELSEST
;
IFST: IF '(' CONDITION ')' { strcpy(QUAD[Index].op,"=="); 
strcpy(QUAD[Index].arg1,$3);
 strcpy(QUAD[Index].arg2,"FALSE");
  strcpy(QUAD[Index].result,"-1");
   push(Index);
Index++;
}
BLOCK { strcpy(QUAD[Index].op,"GOTO");
 strcpy(QUAD[Index].arg1,"");
strcpy(QUAD[Index].arg2,""); 
strcpy(QUAD[Index].result,"-1");
push(Index);
Index++;
};
ELSEST: ELSE{
tInd=pop();
 Ind=pop();
  push(tInd);
sprintf(QUAD[Ind].result,"%d",Index);
}
BLOCK{
Ind=pop();
sprintf(QUAD[Ind].result,"%d",Index);
};
CONDITION: VAR RELOP VAR {AddQuadruple($2,$1,$3,$$);
StNo=Index-1;
}
| VAR
| NUM
;
WHILEST: WHILELOOP{
Ind=pop();
sprintf(QUAD[Ind].result,"%d",StNo);
 Ind=pop();
sprintf(QUAD[Ind].result,"%d",Index);
}
;
WHILELOOP: WHILE '(' CONDITION ')' { strcpy(QUAD[Index].op,"=="); 
strcpy(QUAD[Index].arg1,$3); 
strcpy(QUAD[Index].arg2,"FALSE"); 
strcpy(QUAD[Index].result,"-1");
push(Index);
Index++;
}
BLOCK {
strcpy(QUAD[Index].op,"GOTO"); 
strcpy(QUAD[Index].arg1,""); 
strcpy(QUAD[Index].arg2,""); 
strcpy(QUAD[Index].result,"-1"); 
push(Index);
Index++;
}
;
%%
extern FILE *yyin;
int main(int argc,char *argv[])
{
FILE *fp;
int i;
    if(argc>1) {
        fp=fopen(argv[1],"r");
            if(!fp) {
                printf("\n File not found");
                exit(0); 
                } 
        yyin=fp; 
        }
yyparse();
printf("\n\n\t\t ----------------------------","\n\t\t Pos Operator Arg1 Arg2 Result", "\n\t\t--------------------"); 
for(i=0;i<Index;i++)
{
printf("\n\t\t %d\t %s\t %s\t %s\t%s",i,QUAD[i].op,QUAD[i].arg1,QUAD[i].arg2,QUAD[i].result);
}
printf("\n\t\t -----------------------");
printf("\n\n"); 
return 0; }

void push(int data){ 
    stk.top++; 
        if(stk.top==100)
        {
            printf("\n Stack overflow\n");
            exit(0); }
            stk.items[stk.top]=data;
        } 
int pop() { 
    int data; 
        if(stk.top==-1){
            printf("\n Stack underflow\n");
            exit(0); 
            }
    data=stk.items[stk.top--];
    return data;
 }
void AddQuadruple(char op[5],char arg1[10],char arg2[10],char result[10]){
    strcpy(QUAD[Index].op,op);
    strcpy(QUAD[Index].arg1,arg1);
    strcpy(QUAD[Index].arg2,arg2);
    sprintf(QUAD[Index].result,"t%d",tIndex++);
    strcpy(result,QUAD[Index++].result);
    } 

yyerror() {
printf("\n Error on line no:%d",LineNo);
}

-------------------------for---------------------------------

%{
#include "y.tab.h"
%}

%%
for					return FOR;
[\(\)]					return PARANTHESIS;
[a-zA-Z0-9]*				return OPERAND;
"="|"<"|">"|">="|"<="|"=="|"++"|"--"	return OPERATOR;
\;					return SEMICOLON;
,					return COMMA;
[\{\}]                  return CURLYBRACE;
                 
\n					return NEWLINE;
.					;
%%

int yywrap()
{
	return 1;
}
/*
                To run:
yacc -d for.y
lex for.l
gcc lex.yy.c y.tab.c -o for -ll 
./for


Input format:  for(i=0;i<10;i++){for(j=0;j<10;j++){}
}
Click Clt + D after the input. (Click ENTER after closing curly braces '}')

 
                */




//////////////////////////////////////////

%{
	#include <stdio.h>
	int valid = 1;
%}

%token FOR PARANTHESIS OPERAND OPERATOR COMMA SEMICOLON NEWLINE CURLYBRACE

%%
start: FOR PARANTHESIS A A B PARANTHESIS CURLYBRACE start CURLYBRACE NEWLINE| ;
A: OPERAND OPERATOR OPERAND SEMICOLON | OPERAND OPERATOR OPERAND COMMA A | SEMICOLON;
B: OPERAND OPERATOR | OPERAND OPERATOR COMMA B |;
%%

int yyerror()
{
	valid = 0;
	printf("Invalid.\n");
	return 1;
}
 
void main()
{
	printf("Enter string:\n");
	yyparse();

	if (valid)
		printf("Valid.\n");
}

--------------------------dowhile----------------------------------------------
%{
    #include "y.tab.h"
%}
%%
"do" {return DO;}
"while" {return WHILE;}
[a-zA-Z0-9]* return STMT;
"("[a-zA-Z0-9]+(">"|"<"|">="|"<="|"==")[a-zA-Z0-9]+")"  { return CONDITION; }
"{" { return '{'; }
"}" { return '}'; }
\n         ;
[ \t]      ;

%%
int yywrap(){
    return 1;
}

///////////////////////////////

%{
#include <stdio.h>
#include <stdlib.h>

void yyerror(char *s);
int yylex(void);


%}

%token DO WHILE CONDITION STMT

%%
PROGRAM: START {printf("Valid Syntax of do while\n");}
START: DO '{' STMT_LIST '}' WHILE CONDITION;
STMT_LIST: | START STMT_LIST | STMT;

%%


int main() {
    printf("Enter the do-while stmt to check for syntax validity: \n ");
    yyparse();   // Parse the input
    
    return 0;
}


void yyerror(char *s) {
    fprintf(stderr, "Error: %s\n", s);
}

-----------------------------ifelse-------------------------------------------

%{
#include "y.tab.h"
%}

%%

"if"       { return IF; }
"else if"  { return ELSEIF; }
"else"     { return ELSE; }

"("[a-zA-Z0-9]+(">"|"<"|">="|"<="|"==")[a-zA-Z0-9]+")"  { return CONDITION; }
[a-zA-Z0-9]* {return STMT;}
"{" { return '{'; }
"}" { return '}'; }
\n         ;
[ \t]      ;

%%

int yywrap() {
    return 1;
}
/////////////////////////////////////

%{
#include <stdio.h>
#include <stdlib.h>
%}

%token IF ELSEIF ELSE STMT
%token CONDITION

%%
program:
        statement{printf("Valid Syntax of if-else\n");}
        ;

statement:
        if_statement
        ;

if_statement:
        IF CONDITION '{' statement_list'}' elseif_statements else_statement 
        ;

elseif_statements:
        /* epsilon */
        | ELSEIF CONDITION '{' statement_list '}' elseif_statements
        ;

else_statement:
        /* epsilon */
        | ELSE '{'statement_list'}'
        ;

statement_list:
        /* epsilon */
        | statement statement_list
        | STMT
        ;

%%

int main() {
    yyparse();
    return 0;
}

void yyerror(const char *s) {
    fprintf(stderr, "Error: %s\n", s);
}

-------------------switch-------------------------------

%{
    #include "y.tab.h"
%}
%%
"switch" {return SWITCH;}
"default:" {return DEFAULT;}
"break" return BREAK;
"("[a-zA-Z0-9]+")"  { return EXPR; }
"case("[a-zA-Z0-9]+"):" {return CASE;}

[a-zA-Z0-9]* {return STMT;}
"{" { return '{'; }
"}" { return '}'; }
\n  ;       ;
[ \t]      ;
%%
int yywrap(){
    return 1;
}

////////////////////////////////

%{
    #include <stdio.h>
    #include <stdlib.h>
    int yyparse();
    void yyerror();
    int valid=1;
%}
%token SWITCH CASE DEFAULT STMT EXPR BREAK
%%
PROGRAM: START {printf("Valid switch syntax\n");};
START: SWITCH EXPR '{'  CASES DEF_STMT '}';
CASES: CASE STMT_LIST BREAK CASES | ;
DEF_STMT: DEFAULT STMT_LIST |  ;
STMT_LIST:START STMT_LIST| STMT STMT_LIST| ;

%%
void yyerror(){
    printf("Not valid");
  
}

int main() {
    printf("Enter an switch statementto check for validity:\n ");
    yyparse();   // Parse the input
        
    return 0;
}


-----------------------operator-----------------------------------------------------



#include<stdio.h>
#include <string.h>
  

void main() {
  char stack[20], ip[20], opt[10][10], ter[10];
  int i, j, k, n, top = 0, col, row;

  for (i = 0; i < 10; i++) {
    stack[i] = NULL;
    ip[i] = NULL;
    for (j = 0; j < 10; j++) {
      opt[i][j] = NULL;
    }
  }
  printf("Enter the no.of terminals :\n");
  scanf("%d", &n);
  printf("\nEnter the terminals :\n");
  scanf("%s", &ter);
  printf("\nEnter the table values :\n");
  for (i = 0; i <n; i++) {
    for (j = 0; j < n; j++) {
      printf("Enter the value for %c %c:", ter[i], ter[j]);
      scanf("%s", opt[i][j]);
    }
  }
  printf("\n**** OPERATOR PRECEDENCE TABLE ****\n");
  for (i = 0; i < n; i++) {
    printf("\t%c",ter[i]);
  }
  printf("\n");
  for (i = 0; i < n; i++) {
    printf("\n%c", ter[i]);
    for (j = 0; j < n; j++) {
      printf("\t%c", opt[i][j]);
    }
  }
  stack[top] = '$';
  printf("\nEnter the input string:");
  scanf("%s", ip);
  i = 0;
  printf("\nSTACK\t\t\tINPUT STRING\t\t\tACTION\n");
  printf("\n%s\t\t\t%s\t\t\t", stack, ip);
  while (i <= strlen(ip)) {
    for (k = 0; k < n; k++) {
      if (stack[top] == ter[k])
        row = k;
      if (ip[i] == ter[k])
        col = k;
    }
    if ((stack[top] == '$') && (ip[i] == '$')) {
      printf("String is accepted\n");
      break;
    } else if ((opt[row][col] == '<') || (opt[row][col] == '=')) {
      stack[++top] = opt[row][col];
      stack[++top] = ip[i];
      printf("Shift %c", ip[i]);
      i++;
    } else {
      if (opt[row][col] == '>') {
        while (stack[top] != '<') {
          --top;
        }
        top = top - 1;
        printf("Reduce");
      } else {
        printf("\nString is not accepted");
        break;
      }
    }
    printf("\n");
    for (k = 0; k <= top; k++) {
      printf("%c", stack[k]);
    }
    printf("\t\t\t");
    for (k = i; k < strlen(ip); k++) {
      printf("%c", ip[k]);
    }
    printf("\t\t\t");
  }
  getchar();
}



-------------------------------firstfollow--------------------------------------------------

#include <stdio.h>
#include <string.h>

int n;
char prods[50][50];
char firsts[26][50];
int is_first_done[26];

char follows[26][50];
int is_follow_done[26];

int isTerminal(char c)
{
    if (c < 65 || c > 90)
        return 1;
    return 0;
}

void first(char nonterm)
{
    int index = 0;
    char curr_firsts[50];
    for (int i = 0; i < n; i++)
    {
        if (prods[i][0] == nonterm)
        {

            int curr_prod_index = 2;

            int flag = 0;
            while (prods[i][curr_prod_index] != '\0' && flag == 0)
            {
                flag = 1;
                if (isTerminal(prods[i][curr_prod_index]))
                {
                    curr_firsts[index] = prods[i][curr_prod_index];
                    index++;
                    break;
                }

                if (!is_first_done[prods[i][curr_prod_index] - 65])
                    first(prods[i][curr_prod_index]);

                int in = 0;
                while (firsts[prods[i][curr_prod_index] - 65][in] != '\0')
                {
                    curr_firsts[index] = firsts[prods[i][curr_prod_index] - 65][in];
                    if (firsts[prods[i][curr_prod_index] - 65][in] == 'e')
                    {
                        curr_prod_index++;
                        flag = 0;
                    }
                    index++;
                    in++;
                }
            }
        }
    }

    curr_firsts[index] = '\0';
    index++;
    strcpy(firsts[nonterm - 65], curr_firsts);
    is_first_done[nonterm - 65] = 1;
}

void follow(char nonterm)
{
    int index = 0;
    char curr_follows[50];
    if (nonterm == prods[0][0])
    {
        curr_follows[index] = '$';
        index++;
    }
    for (int j = 0; j < n; j++)
    {
        int k = 2;
        int include_lhs_flag;
        while (prods[j][k] != '\0')
        {
            include_lhs_flag = 0;
            if (prods[j][k] == nonterm)
            {
                if (prods[j][k + 1] != '\0')
                {
                    if (isTerminal(prods[j][k + 1]))
                    {
                        curr_follows[index] = prods[j][k + 1];
                        index++;
                        break;
                    }

                    int in = 0;
                    while (firsts[prods[j][k + 1] - 65][in] != '\0')
                    {
                        if (firsts[prods[j][k + 1] - 65][in] == 'e')
                        {
                            include_lhs_flag = 1;
                            in++;
                            continue;
                        }

                        int temp_flag = 0;
                        for (int z = 0; z < index; z++)
                            if (firsts[prods[j][k + 1] - 65][in] == curr_follows[z])
                            {  
                                temp_flag = 1;
                                in++;
                                break;
                            }
                        if (temp_flag)
                            continue;

                        curr_follows[index] = firsts[prods[j][k + 1] - 65][in];
                        index++;
                        in++;
                    }
                }

                if (prods[j][k + 1] == '\0' || include_lhs_flag == 1)
                {
                    if (prods[j][0] != nonterm)
                    {
                        if (!is_follow_done[prods[j][0] - 65])
                            follow(prods[j][0]);
                        int x = 0;
                        while (follows[prods[j][0] - 65][x] != '\0')
                        {
                            int temp_flag = 0;
                            for (int z = 0; z < index; z++)
                                if (follows[prods[j][0] - 65][x] == curr_follows[z])
                                {
                                    temp_flag = 1;
                                    x++;
                                    break;
                                }
                            if (temp_flag)
                                continue;
                            curr_follows[index] = follows[prods[j][0] - 65][x];
                            index++;
                            x++;
                        }
                    }
                }
            }
            k++;
        }
    }

    curr_follows[index] = '\0';
    index++;
    strcpy(follows[nonterm - 65], curr_follows);
    is_follow_done[nonterm - 65] = 1;
}

int main()
{
    printf("Enter the number of productions\n");
    scanf("%d", &n);
    printf("Enter productions: \n");
    for (int i = 0; i < n; i++)
        scanf("%s", prods[i]);

    for (int i = 0; i < 26; i++)
        is_first_done[i] = 0;


    for (int i = 0; i < n; i++)
        if (is_first_done[prods[i][0] - 65] == 0)
            first(prods[i][0]);

    for (int i = 0; i < n; i++)
        if (is_follow_done[prods[i][0] - 65] == 0)
            follow(prods[i][0]);

    printf("Firsts:\n");
    for (int i = 0; i < 26; i++)
        if (is_first_done[i])
            printf("%c : %s\n", i + 65, firsts[i]);

    printf("Follows:\n");
    for (int i = 0; i < 26; i++)
        if (is_follow_done[i])
            printf("%c : %s\n", i + 65, follows[i]);
}


//////alternate/////////

#include <stdio.h>

#include <math.h>

#include <string.h>

#include <ctype.h>

#include <stdlib.h>

int n, m = 0, p, i = 0, j = 0;
char a[10][10], f[10];
void follow(char c);
void first(char c);
int main()
{
  int i, z;
  char c, ch;
  printf("Enter the no of productions : \n");
  scanf("%d", &n);
  printf("Enter the productions:\n");
  for (i = 0; i < n; i++)
    scanf("%s%c", a[i], &ch);
  do
  {
    m = 0;
    printf("Enter a variable whose fisrt & follow is to be found:");

    scanf("%c", &c);
    first(c);
    printf("First(%c)={", c);
    for (i = 0; i < m; i++)
      printf("%c", f[i]);
    printf("}\n");
    strcpy(f, " ");
    m = 0;
    follow(c);
    printf("Follow(%c)={", c);
    for (i = 0; i < m; i++)
      printf("%c", f[i]);
    printf("}\n");
    printf("Want to continue or not(1/0) ? ");
    scanf("%d%c", &z, &ch);
  } while (z == 1);
  return (0);
}
void first(char c)
{
  int k;
  if (!isupper(c))
    f[m++] = c;
  for (k = 0; k < n; k++)
  {
    if (a[k][0] == c)
    {
      if (a[k][2] == 'e')
        follow(a[k][0]);
      else if (islower(a[k][2]))
        f[m++] = a[k][2];
      else
        first(a[k][2]);
    }
  }
}
void follow(char c)
{
  if (a[0][0] == c)
    f[m++] = '$';
  for (i = 0; i < n; i++)
  {
    for (j = 2; j < strlen(a[i]); j++)
    {
      if (a[i][j] == c)
      {
        if (a[i][j + 1] != '\0')
          first(a[i][j + 1]);
        if (a[i][j + 1] == '\0' && c != a[i][0])
          follow(a[i][0]);
      }
    }
  }
}


--------------------recursive-------------------------------------------------

#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<ctype.h>

char ip_sym[15],ip_ptr=0,op[50],tmp[50];
void e_prime();
void e();
void t_prime();
void t();
void f();
void advance();
int n=0;
void e()
{
 strcpy(op,"TE'");
 printf("E=%-25s",op);
 printf("E->TE'\n");
 t();
 e_prime();
}
void e_prime()
{
int i,n=0,l;
for(i=0;i<=strlen(op);i++)
    if(op[i]!='e')
 tmp[n++]=op[i];
strcpy(op,tmp);
l=strlen(op);
for(n=0;n < l && op[n]!='E';n++);
if(ip_sym[ip_ptr]=='+')
 {
     i=n+2;
 do
 {
 op[i+2]=op[i];
 i++;
 }while(i<=l);
  op[n++]='+';
  op[n++]='T';
  op[n++]='E';
  op[n++]=39;
  printf("E=%-25s",op);
  printf("E'->+TE'\n");
  advance();
  t();
  e_prime();
 }
 else
 {
     op[n]='e';
  for(i=n+1;i<=strlen(op);i++)
 op[i]=op[i+1];
 printf("E=%-25s",op);
 printf("E'->e");
 }
}
void t()
{
 int i,n=0,l;
 for(i=0;i<=strlen(op);i++){
   if(op[i]!='e'){
       tmp[n++]=op[i];
   }
  
 }
  
strcpy(op,tmp);
l=strlen(op);//op=TE'
for(n=0;n < l && op[n]!='T';n++);
//n=0, i=1
 i=n+1;
 do
 {
  op[i+2]=op[i];
  i++;
 }while(i < l);
 op[n++]='F';
 op[n++]='T';
 op[n++]=39;
 printf("E=%-25s",op);
 printf("T->FT'\n");
 f();
 t_prime();
}

void t_prime()
{
int i,n=0,l;
for(i=0;i<=strlen(op);i++)
    if(op[i]!='e')
 tmp[n++]=op[i];
strcpy(op,tmp);
l=strlen(op);
for(n=0;n < l && op[n]!='T';n++);
if(ip_sym[ip_ptr]=='*')
 {
     i=n+2;
 do
 {
 op[i+2]=op[i];
 i++;
 }while(i < l);
  op[n++]='*';
  op[n++]='F';
  op[n++]='T';
  op[n++]=39;
  printf("E=%-25s",op);
  printf("T'->*FT'\n");
  advance();
  f();
  t_prime();
 }
 else
 {
   op[n]='e';
  for(i=n+1;i<=strlen(op);i++)
 op[i]=op[i+1];
 printf("E=%-25s",op);
 printf("T'->e\n");
 }
}

void f()
{
int i,n=0,l;
for(i=0;i<=strlen(op);i++)
    if(op[i]!='e')
 tmp[n++]=op[i];
 strcpy(op,tmp);
l=strlen(op);
for(n=0;n < l && op[n]!='F';n++);
 if((ip_sym[ip_ptr]=='i')||(ip_sym[ip_ptr]=='I'))
 {
 op[n]='i';
 printf("E=%-25s",op);
 printf("F->i\n");
 advance();
 }
 else
 {
  if(ip_sym[ip_ptr]=='(')
  {
   advance();
   e();
   if(ip_sym[ip_ptr]==')')
   {
    advance();
     i=n+2;
 do
 {
 op[i+2]=op[i];
 i++;
 }while(i<=l);
  op[n++]='(';
  op[n++]='E';
  op[n++]=')';
  printf("E=%-25s",op);
  printf("F->(E)\n");
   }
  }
  else
  {
   printf("\n\t syntax error");
     exit(1);
  }
 }
}

void advance()
{
 ip_ptr++;
}
void main()
{
 int i;
  printf("\nGrammar without left recursion");
 printf("\n\t\t E->TE' \n\t\t E'->+TE'|e \n\t\t T->FT' ");
 printf("\n\t\t T'->*FT'|e \n\t\t F->(E)|i");
 printf("\n Enter the input expression:");
 scanf("%s",ip_sym);
 printf("Expressions");
 printf("\t Sequence of production rules\n");
  e();
  for(i=0;i < strlen(ip_sym);i++)
 {
  if(ip_sym[i]!='+'&&ip_sym[i]!='*'&&ip_sym[i]!='('&&
     ip_sym[i]!=')'&&ip_sym[i]!='i'&&ip_sym[i]!='I')
  {
   printf("\nSyntax error");
   break;
  }
  for(i=0;i<=strlen(op);i++)
    if(op[i]!='e')
 tmp[n++]=op[i];
    strcpy(op,tmp);
    printf("\nE=%-25s",op);
 }
 printf("\n\n");
}

/////alternate/////////

#include<stdio.h>

#include<string.h>

#include<ctype.h>

char input[10];
int i, error;
void E();
void T();
void Eprime();
void Tprime();
void F();
void main() {
  i = 0;
  error = 0;
  printf("Enter an arithmetic expression : ");
  gets(input);
  E();
  if (strlen(input) == i && error == 0)
    printf("\nAccepted..!!!\n");
  else printf("\nRejected..!!!\n");
}

void E() {
  T();
  Eprime();
}
void Eprime() {
  if (input[i] == '+') {
    i++;
    T();
    Eprime();
  }
}
void T() {
  F();
  Tprime();
}
void Tprime() {
  if (input[i] == '*') {
    i++;
    F();
    Tprime();
  }
}
void F() {
  if (isalnum(input[i])) i++;
  else if (input[i] == '(') {
    i++;
    E();
    if (input[i] == ')')
      i++;
    else error = 1;
  } else error = 1;
}


-----------------------------------shift---------------------------

#include <stdio.h>
#include <string.h>

#define MAX_INPUT 100
#define MAX_STACK 100

void check();

char input[MAX_INPUT], stack[MAX_STACK], action[20];
int input_len, stack_top = -1;

int main() {
    printf("GRAMMAR is:\nE -> E+E | E*E | (E) | id\n");
    printf("Enter input string: ");
    scanf("%s", input);
    input_len = strlen(input);

    printf("\nStack\t\tInput\t\tAction\n");

    for (int i = 0; i < input_len; i++) {
        if (input[i] == 'i' && input[i+1] == 'd') {
            stack[++stack_top] = 'i';
            stack[++stack_top] = 'd';
            stack[stack_top + 1] = '\0';
            printf("$%s\t\t%s$\t\tSHIFT->id\n", stack, input + i + 2);
            check();
            i++;  // Skip the 'd' in the next iteration
        } else {
            stack[++stack_top] = input[i];
            stack[stack_top + 1] = '\0';
            printf("$%s\t\t%s$\t\tSHIFT->%c\n", stack, input + i + 1, input[i]);
            check();
        }
    }

    if (stack_top == 0 && stack[0] == 'E') {
        printf("\nInput string is VALID.\n");
    } else {
        printf("\nInput string is INVALID.\n");
    }

    return 0;
}

void check() {
    int i, j, handle_size;
    char *handle;

    while (1) {
        if (stack_top >=1 && stack[stack_top-1] == 'i' && stack[stack_top] == 'd') {
            handle = "id";
            handle_size = 2;
        } else if (stack_top >= 2 && stack[stack_top-2] == 'E' && stack[stack_top-1] == '+' && stack[stack_top] == 'E') {
            handle = "E+E";
            handle_size = 3;
        } else if (stack_top >= 2 && stack[stack_top-2] == 'E' && stack[stack_top-1] == '*' && stack[stack_top] == 'E') {
            handle = "E*E";
            handle_size = 3;
        } else if (stack_top >= 2 && stack[stack_top-2] == '(' && stack[stack_top-1] == 'E' && stack[stack_top] == ')') {
            handle = "(E)";
            handle_size = 3;
        } else {
            return;  // No reduction possible
        }

        // Perform reduction
        stack_top -= handle_size - 1;
        stack[stack_top] = 'E';
        stack[stack_top + 1] = '\0';
        printf("$%s\t\t%s$\t\tREDUCE->%s\n", stack, input + strlen(input), handle);
    }
}


---------------------------------intermediate code-----------------------------------


#include <stdio.h>
#include <string.h>
void gen_code_for_operator(char *inp, char operator, char * reg)
{    int i = 0, j = 0;
    char temp[100];
    while (inp[i] != '\0')
    {
        if (inp[i] == operator)
        {
            printf("%c\t%c\t%c\t%c\n", operator, * reg, inp[i - 1], inp[i + 1]);
            temp[j - 1] = *reg; 
            i += 2;
            (*reg)--; 
            continue;
        }
        temp[j] = inp[i];
        i++;
        j++;
    }
    temp[++j] = '\0';
    strcpy(inp, temp);
}

void gen_code(char *inp)
{
    // Operator precedence - /, *, +, -, =
    char reg = 'Z'; 
    gen_code_for_operator(inp, '/', &reg);
    gen_code_for_operator(inp, '*', &reg);
    gen_code_for_operator(inp, '+', &reg);
    gen_code_for_operator(inp, '-', &reg);
    gen_code_for_operator(inp, '=', &reg);
}
int main()
{
    char inp[100];
    printf("Enter expression:\n\n");
    scanf("%s", inp);
    printf("Op  \tDestn\tArg1\tArg2\n");
    gen_code(inp);
}


